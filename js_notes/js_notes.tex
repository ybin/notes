
\documentclass[a4paper,11pt]{article}

\input{../styles/article_preamble}
\input{../styles/tikz_preamble}

\sybtitle{JavaScript Notes}
\sybauthor{孙延宾}
\sybdate{\today}

\begin{document}
\tt % I love Typewriter font.
%%%%%%%% the title page and toc %%%%%%%%%%
\pagestyle{header}
\sybmaketitle
\tableofcontents
\newpage

%%%%%%% the main content %%%%%%%%%
\pagestyle{main}
\setcounter{page}{1}

\part[JavaScript和DOM]{JavaScript和DOM}
\section[DOM是什么]{DOM是什么}
DOM(Document Object Model)是使用"JavaScript对象"来表示网页各个组成部分的方式。
网页被分解为一个个的node，最常用的是element nodes，attribute nodes和
text nodes三种，整个网页(the whole document)用document node来表示。

\section[获取页面元素]{获取页面元素}
获取页面元素有以下几种方式。
\subsection[Element ID]{Element ID}
\begin{javascriptcode}
  var widget = document.getElementById("widget");
  alert(widget);
\end{javascriptcode}

\subsection[Tag name]{Tag name}
\begin{javascriptcode}
  var pars = document.getElementsByTagName("p");
  for(var i = 0; i < pars.length; i++) {
    alert(pars[i]);
  }
\end{javascriptcode}

\subsection[Element name]{Element name}
\begin{javascriptcode}
  var widgetName = document.getElementsByName("widgetName")[0];
  alert(widgetName);
\end{javascriptcode}

\section[DOM node]{DOM node}
DOM将整个页面分解为node objects，所有的一切都是node object。
每个node都有三种属性：nodeType，nodeName，nodeValue。其中
nodeType用数字表示，如Node.ELEMENT\_NODE，nodeName用字符串表示，
如"H1"、"P"。

\subsection[Node之间的关系]{Node之间的关系}
所有的node都有下列属性：

\begin{itemize}
\item childNodes
\item firstChild
\item lastChild
\item nextSibling
\item previousSibling
\item parentNode
\end{itemize}

\subsection[获取node属性]{获取node属性}
第一种方式：通过node的".attributes"属性。

\begin{javascriptcode}
  <input type="text" name="widgetName" id="widget" />
  
  var output = '';
  var widget = document.getElementById("widget");
  var attrs = widget.attributes;
  for(var i = 0; i < attrs.length; i++) {
    output += attrs[i].name + '=' + attrs[i].value + '\n';
  }
  alert(output);
\end{javascriptcode}

第二种方法：getAttribute(name)

\begin{javascriptcode}
  var widget = document.getElementById('widget');
  alert(widget.getAttribute('type')); // display 'text'
  // or
  alert(widget.getAttributeNode('type')); // 打印node而不是其value
\end{javascriptcode}

当然，还可以预先判断某个属性是否存在：

\begin{javascriptcode}
  var isAttributeExists = elem.hasAttribute(attributeName);
\end{javascriptcode}

\subsection[修改node的属性]
改变属性值：

\begin{javascriptcode}
  <div>
    <img id="photo" src="cat.jpg" alt="My cat" />
  </div>

  var photo = document.getElementById('photo');
  var photoSrc = photo.getAttributeNode('src');
  var photoAlt = photo.getAttributeNode('alt');
  photoSrc.value = 'dog.jpg';
  photoAlt.value = 'My dog';
\end{javascriptcode}

增加属性：

\begin{javascriptcode}
  <div>
    <img id="photo" src="cat.jpg" alt="My cat" />
  </div>

  var photo = document.getElementById('photo');
  var width = document.createAttribute('width');
  width.value = 50;
  photo.setAttributeNode(width);
\end{javascriptcode}

快捷方式：

\begin{javascriptcode}
  // 如果name属性存在就修改其值，否则就增加name属性并设置其值为value
  elem.setAttribute(name, value);
\end{javascriptcode}

删除属性：

\begin{javascriptcode}
  //elem.removeAttribute(name);
  var photo = document.getElementById('photo');
  photo.setAttribute('width', 50);
  photo.removeAttribute('width');
\end{javascriptcode}


\subsection[修改node的值]{修改node的值}
修改node的值，只需修改node的nodeValue即可。

\begin{javascriptcode}
  <div id='welcome'> <p>Welcome to Widget.</p></div>
  var welcome = document.getElementById('welcome');
  welcome.firstChild.firstChild.nodeValue = 'Welcome U.';
\end{javascriptcode}

添加新的node：

\begin{javascriptcode}
  // 在尾部增加
  var welcome = document.getElementById('welcome');
  var horizRule = document.createElement('hr');
  welcome.appendChild(horizRule);
  // or
  // 在头部增加
  welcome.insertBefore(horizRule, welcome.firstChild);
\end{javascriptcode}

删除node：

\begin{javascriptcode}
  var welcome = document.getElementById('welcome');
  var horizRule = welcome.lastChild;
  welcome.removeChild(horizRule);
\end{javascriptcode}

替换node：

\begin{javascriptcode}
  var welcome = document.getElementById('welcome');
  var horizRule = welcome.lastChild;
  var newPar = document.createElement('p');
  newPar.appendChild(document.createTextNode('xxxxxx'));
  welcome.replaceChild(newPar, horizRule);
\end{javascriptcode}

移动node：

\begin{javascriptcode}
  <ul>
    <li id="widget1"><a href="superwidget.html">SuperWidget</a></li>
    <li id="widget2"><a href="megawidget.html">MegaWidget</a></li>
    <li id="widget3"><a href="wonderwidget.html">WonderWidget</a></li>
  </ul>
  // 只需将原来的node添加到需要的位置即可，旧的node自动删除，
  // 所以要想复制一个node就要使用createElement才行。
  var superWidget = document.getElementById("widget1");
  var ul = superWidget.parentNode;
  ul.appendChild(superWidget);
\end{javascriptcode}


\section[Prototype]{Prototype}
JavaScript的继承使用的是原型链(prototype chain)方式，原型链方式看似简单，
实则不然，理解原型链需从两方面进行：constructor模式、prototype模式。

\subsection[constructor mode]{constructor mode}
JavaScript 中没有类的概念，我们知道类是OOP中的"模型"，那JS中如何定义模型呢？
答案是“构造函数”，在JS中，new关键词后面跟的是函数，构造函数。构造函数定义了
对象的模型，js中的任何对象都有constructor属性，该属性是对象到其构造函数的通道。
但是如果手动修改constructor属性，该通道也就被改变了，而有时修改构造函数是必须的
[见第\ref{sec:inherit}节]，
所以通过该属性寻找构造函数是十分危险的事情。

\subsection[prototype mode]{prototype mode}
可以给构造函数增加"prototype"属性(函数也是对象哦！)，其值为一个对象，以此来
达到对象的“继承”，这就是prototype mode。prototype属性只在函数中起作用。
另外需注意：

\emph{构造函数里的prototype对象是给其“实例”使用的！}

要想取得对象本身的prototype对象，则需要通过其constructor，

\begin{javascriptcode}
  // 构造函数与普通函数唯一的区别是首字母大写！
  function Foo() {};
  // 构造函数的prototype对象是给其“实例”使用的
  Foo.prototype = {
    foo:42
  };

  // 以Foo为模型，定义新的对象
  var obj = new Foo();
  // 对象的原型需要通过构造函数获得，而不是prototype属性
  var pt = obj.constructor.prototype; // 等于 {foo:42}
\end{javascriptcode}

容易造成迷惑的是函数的prototype属性及函数对象本身的prototype对象，

\begin{javascriptcode}
var pt = {
    bar: 42
};
function Bar() {};
// 函数的prototype属性，供其实例对象使用
Bar.prototype = pt;
alert(Bar.constructor === Function); // true
alert(Bar.constructor.prototype === Function.prototype); // true

// 注意：Object, Function, Array, Date都是函数(Math是对象)
\end{javascriptcode}

\section[变量声明、函数声明提升]{变量声明、函数声明提升}
这个绝对是JavaScript里面的奇葩：var表达式、函数声明被提升到当前
作用域的顶部。

名词解释：

声明(Declaration)：\\
\begin{javascriptcode}
  var joe;
\end{javascriptcode}

初始化(Initialization)：\\
\begin{javascriptcode}
  joe = 'plumber';
\end{javascriptcode}

示例：\\
\begin{javascriptcode}
  function f() {
    var a = 'a';
    // other code
    var b = 'b';
    // other code
    c();
    function c() {
      var aa = 'aa';
      // another code
      var bb = 'bb';
      // another code
    }
    // other code
  }
\end{javascriptcode}

等价于，

\begin{javascriptcode}
  function f() {
    var a, b; // 变量声明
    function c() {
      var aa, bb; // 变量声明
      aa = 'aa';
      // another code
      bb = 'bb';
      // another code
    }
    a = 'a';
    // other code
    b = 'b';
    // other code
    c();
    // other code
  }
\end{javascriptcode}

测试：alert输出时什么呢？\\
\begin{javascriptcode}
  var myvar = 'my value';
  (function () {
    alert(myvar);
    var myvar = 'local value';
  })();
\end{javascriptcode}

答案：undefined

函数声明也是一样的，所以可以在定义函数之前就使用函数！

\section[prototype.constructor]{prototype.constructor}
这绝对是个大坑！！！\label{sec:inherit}

\begin{javascriptcode}
  // 如果Foo是个空函数，即函数体中什么都没有，
  // 那么Foo实例的constructor就会是Object函数，
  // 这太坑爹了吧！
  function Foo() {foo:1};
  function Bar() {bar:1};
  Bar.prototype = new Foo();
  // 这一行是必须的，否则继承链就会紊乱，
  // 因为new新的实例时，新实例的constructor默认设置为
  // 构造函数的prototype.constructor，除非构造函数
  // 没有prototype属性，太坑爹了！
  var bar0 = new Bar();
  // bar0.constructor === Foo; // true!!!
  // 所以，修改构造函数的prototype属性时，后面跟的必定是
  // 修改prototype对象构造函数这一步！！！
  Bar.prototype.constructor = Bar;
  var bar = new Bar();
  // bar.constructor === Bar; // true
  
\end{javascriptcode}

\section[prototype mode详解]{prototype mode详解}
以下三种继承方式，其prototype chain是完全不同的。

\begin{javascriptcode}
  // Foo 构造函数
  function Foo() { foo1:1 };
  foo.prototype = { foo2:2 };

  // Bar 构造函数
  function Bar() { bar1:11 };

  // 这里填写继承关系，见下面三种继承方式

  var foo = Foo();
  var bar = Bar();
\end{javascriptcode}

\subsection[父子关系]{父子关系}
第一种继承方式：父子关系

\begin{javascriptcode}
  Bar.prototype = new Foo();
  // 这是必须的！
  Bar.prototype.constructor = Bar;
\end{javascriptcode}

继承链：\\
bar\\
=> Foo的实例（即new Foo()）\\
=> Foo.prototype对象\\
=> Object.prototype对象（即{}，空对象）\\
foo与bar是父子关系。这是最常见的继承方式。

\subsection[兄弟关系]{兄弟关系}
第二种继承方式：兄弟关系

\begin{javascriptcode}
  Bar.prototype = Foo.prototype;
\end{javascriptcode}

继承链：\\
bar\\
=> Foo.prototype对象\\
=> Object.prototype对象（即{}，空对象）\\
foo\\
=> Foo.prototype对象\\
=> Object.prototype对象（即{}，空对象）\\
foo与bar是兄弟关系。

\subsection[陌生关系]{陌生关系}
第三种继承方式：陌生关系

\begin{javascriptcode}
  Bar.prototype = Foo;
\end{javascriptcode}

继承链：\\
bar\\
=> Foo对象（函数也是对象）\\
=> Foo.constructor.prototype（即Function.prototype）\\
foo\\
=> Foo.prototype\\
=> Object.prototype对象（即{}，空对象）\\
Foo的实例与Bar的实例没有关系。

\end{document}