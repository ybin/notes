\documentclass[a4paper,11pt]{article}

\input{../styles/article_preamble}
\input{../styles/tikz_preamble}

\sybtitle{Algorithm Notes}
\sybauthor{孙延宾}
\sybdate{\today}

\begin{document}
  \tt % I love Typewriter font.
%%%%%%%% the title page and toc %%%%%%%%%%
  \pagestyle{header}
  \sybmaketitle
  \tableofcontents
  \newpage

%%%%%%% the main content %%%%%%%%%
  \pagestyle{main}
  \setcounter{page}{1}

  \section[rsync核心算法]{rsync核心算法}
  aaa

  \section[伙伴算法简易实现]{伙伴算法简易实现}
  \begin{center}
    % Requires \usepackage{graphicx}
    \input{inputdir/full_binary_tree}
    %\caption{buddy system}\label{fig:buddy}
  \end{center}


  从伙伴算法看满二叉树的一些特性：
  \begin{description}
    \item[total\_leaf\_size] 满二叉树的叶子节点总数
    \item[level] 满二叉树的层级，范围0-max\_depth
    \item[node\_size] 每个level上节点的size
    \item[index] 某个节点在满二叉树数组中的索引
    \item[offset] 某一个节点对应的内存单元映射到叶子节点数组中的下标(offset)
  \end{description}
  total\_leaf\_size是已知的，即buddy system管理的内存单元总数。
  $$ max\_depth = \log_2total\_leaf\_size$$
  每个level上第一个左子树的index为$2^{level} - 1$
  \begin{align*}
    offset & = [index - (2^{level} - 1)] * node\_size \\
           & = (index + 1) * node\_size - 2^{level} * node\_size \\
           & = (index + 1) * node\_size - 2^{level} * 2^{max\_depth - level} \\
           & = (index + 1) * node\_size - 2^{max\_depth} \\
           & = (index + 1) * node\_size - total\_leaf\_size \\
  \end{align*}
  可见，无论哪个level，第一个左子树(最左边的节点)对应到叶子节点数组中的下标总是0.

  \section[字符串匹配的KMP算法]{字符串匹配的KMP算法}

  \section[字符串匹配的Boyer-Moore算法]{字符串匹配的Boyer-Moore算法}
  
  \section[寻找小于N的所有素数]{寻找小于N的所有素数}
  Sieve筛选算法用于寻找小于N的所有素数。\par
  \inputminted[linenos,tabsize=4,bgcolor=srcbg]{cpp}{srcdir/Sieve.c}
  
  筛选的方法是：\\
  首先去掉2的倍数，然后去掉3的倍数，然后去掉4的倍数，然后，...，
  直到去掉所有sqrt(n)的倍数，如下表：\par
  \begin{tikzpicture}
    \matrix [matrix of nodes]
    {
      2*\textcolor{red}{2} & 3*\textcolor{red}{2} & 4*\textcolor{red}{2} & 5*\textcolor{red}{2} & $\cdots$ & $\frac{n}{2}$ \\
      2*\textcolor{red}{3} & 3*\textcolor{red}{3} & 4*\textcolor{red}{3} & 5*\textcolor{red}{3} & $\cdots$ & $\frac{n}{3}$ \\
      2*\textcolor{red}{4} & 3*\textcolor{red}{4} & 4*\textcolor{red}{4} & 5*\textcolor{red}{4} & $\cdots$ & $\frac{n}{4}$ \\
      2*\textcolor{red}{5} & 3*\textcolor{red}{5} & 4*\textcolor{red}{5} & 5*\textcolor{red}{5} & $\cdots$ & $\frac{n}{5}$ \\
    };
  \end{tikzpicture}
  
  一般来说，任意一个小于sqrt(n)的数p，我们要去掉：\\
  2*p, 3*p, 4*p, 5*p, $\cdots$, p*p, (p+1)*p, (p+2)*p, $\cdots$\\
  观察一下可以发现，p*p以前的数字，在处理2、3、4、5、$\cdots$、(p-1)*p的倍数时
  都已经去掉了，所以对于p，我们从p*p开始移除。
  
  另外，为何只处理小于等于sqrt(n)的数字呢(上表中一直处理到n)，从上面的说明可以知道，
  如果$p>sqrt(n)$，$p*p>n$，无需处理，而p*p之前的数字都已经移除了，
  也无需处理，所以如果$p>sqrt(n)$，则p无需处理。
  
  该方法的缺点是占用内存太大！

  \part[位操作算法实例]{位操作算法实例}
  aaa



\end{document}
