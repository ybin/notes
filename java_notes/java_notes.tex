
\documentclass[a4paper,11pt]{article}

\input{../styles/article_preamble}
\input{../styles/tikz_preamble}

\sybtitle{Java Notes}
\sybauthor{孙延宾}
\sybdate{\today}

\begin{document}
\tt % I love Typewriter font.
%%%%%%%% the title page and toc %%%%%%%%%%
\pagestyle{header}
\sybmaketitle
\tableofcontents
\newpage

%%%%%%% the main content %%%%%%%%%
\pagestyle{main}
\setcounter{page}{1}

\part[Basic Usage]{Basic Usage}
\section[Enumeration vs Iterator]{Enumeration vs Iterator}
Enumeration和Iterator都是用于遍历集合，Enumeration主要用于遍历
Vector、HashTable，而Iterator用于遍历其他集合。两者的主要区别是：
Enumeration不可以在遍历过程中删除元素，而Iterator则可以，
比较Enumeration和Iterator的定义就可以明确这一点。

下面是Enumeration的定义，

\begin{javacode}
public interface Enumeration<E> {
  boolean hasMoreElements();
  E nextElement();
}
\end{javacode}

下面是Iterator的定义，

\begin{javacode}
public interface Iterator<E> {
  boolean hasNext();
  E next();
  void remove();
}
\end{javacode}

另附使用实例(Vector既可以Enumeration遍历也可用Iterator遍历)，

\begin{javacode}
Vector<String> v = new Vector<String>();
v.add("A");
v.add("B");
v.add("C");

// 使用Enumeration遍历
// 'for' version
String elem;
for(Enumeration<String> e = v.elements(); e.hasMoreElements(); ) {
  elem = e.nextElement();
  System.out.println(elem);
}
// 'while' version
Enumeration<String> e = v.elements();
while(e.hasMoreElements()) {
  elem = e.nextElement();
  System.out.println(elem);
}

// 使用Iterator遍历
// 'for' version
String cur;
for(Iterator<String> iter = v.iterator(); iter.hasNext(); ) {
  cur = iter.next();
  System.out.println(cur);
  if("B".equals(cur)) {
    iter.remove();
  }
}
// 'while' version
Iterator<String> iter = v.iterator();
while(iter.hasNext()) {
  cur = iter.next();
  System.out.println(cur);
  if("B".equals(cur)) {
    iter.remove();
  }
}
\end{javacode}

\section[遍历Map]{遍历Map}
遍历Map时需要从collection的视角去看Map。

\begin{javacode}
public void operateMap() {
  HashMap<String, String> info = new HashMap<String, String>() {
    private static final long serialVersionUID = 1L;
    {
      put("John", "42");
      put("Eric", "43");
      put("Waston", "44");
    }
  };

  /*
   * Collection<E> interface extends Iterable<T> interface,
   * so all Collection including Set<E>, List<E>, Queue<E>
   * can get an Iterator via iterator() method.
   */

  // 遍历Map - 1
  Iterator<Entry<String, String>> entryIter = info.entrySet().iterator();
  while(entryIter.hasNext()) {
    Entry<String, String> entry = entryIter.next();
    System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
  }

  // 遍历Map - 2
  Iterator<String> keyIter = info.keySet().iterator();
  while(keyIter.hasNext()) {
    String key = keyIter.next();
    String value = info.get(key);
    System.out.println("key: " + key + ", value: " + value);
  }

  // 遍历Map - 3，遍历Value
  Iterator<String> valueIter = info.values().iterator();
  while(valueIter.hasNext()) {
    String value = valueIter.next();
    System.out.println("value: " + value);
  }
}
\end{javacode}

\section[Print system properties]{Print system properties}
\begin{javacode}
public void printSystemProperties() {
  Properties p = System.getProperties();
  Enumeration<Object> e = p.keys();
  String key;

  for( ; e.hasMoreElements(); ) {
    key = (String) e.nextElement();
    System.out.println(key + " = " + p.getProperty(key));
  }
}
\end{javacode}

\section[Inner Class]{Inner Class}
Java中，Inner class的field/method相当于Outer class的field/method，
只不过要通过Inner class或Inner class的对象对其进行访问而已。

\subsection[内部类的可见性]{内部类的可见性}
内部类的field/method跟外部类的field/method本质上是一样的，只是访问
方式不同而已，所以内部类和外部类相互之间是“完全透明”的。

\subsection[Create object of Inner class ]{Create object of Inner class}
由于non-static inner class依附于outer class而存在，所以创建这种类型的
对象时必须有outer class对象存在才行；而对于static inner class则无此限制。

\begin{javacode}
class Outer {
  private int out = 42;

  // non-static inner class
  public class InstanceInner {
    private int instanceInner = out;
  }

  // static inner class
  public static class StaticInner {
    private static int staticInner;
  }

  private void out() {
    // access 'private' field of inner class
    int i = new InstanceInner().instanceInner;
    int k = StaticInner.staticInner;
  }
}

class Test {
  void test() {
    Outer outer = new Outer();
    // non-static内部类依附于外部类而存在，所以实例化时必须存在外部类对象
    InstanceInner iInner = outer.new InstanceInner();
    // static内部类则可直接实例化，不需外部类对象存在
    StaticInner sInner = new Outer.StaticInner();
  }
}
\end{javacode}

\subsection[Inner class for JVM]{Inner class for JVM}
在JVM看来，inner class是如何表示的呢？

\emph{在JVM中，根本没有inner class这个概念！一切都是顶级类！}

只是内部类最终编译成class文件时，其名称是...\$...class这样的形式。

啊？那岂不是说：类的private成员可以被外部类(not outer class)访问？


\section[Double braces initialization]{Double braces initialization}
要讲明白双大括号初始化就要先了解什么是instance initializer和static initializer，
该部分Java语言规范在\href{http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.6}{JLS 8.6}。

\begin{javacode}
class Initializer {

  // executed when an instance of the class is created
  static {
    System.out.println("static initializer");
  }

  // executed when the class is initialized
  {
    System.out.println("instance initializer");
  }

  public Initializer() {
    System.out.println("constructor");
  }

  void initialize() {
    System.out.println("instance method");
  }
}
\end{javacode}

执行顺序：static initializer, instance initializer, constructor。

Java支持匿名内部类(Inner anonymous class)，既然是匿名的，就无法在其他地方引用，
因此也就只能在创建类的同时创建对象(毕竟，类不用来创建对象还能干啥呢)，内层的
大括号即为instance initializer。

于是乎，有了下面的代码，

\begin{javacode}
package com.example.javademo;
Class DoubleBraceTest {
  void test() {
    // 初始化HashMap
    HashMap<String, String> hm = new HashMap<String, String>() {
      // instance initializer(对比static initializer)
      {
        // 匿名内部类的this指向父类(即HashMap)对象
        this.put("k1", "v1");
        this.put("k2", "v2");
        this.put("k3", "v3");
      }
    }

    // 任意类都可以，Base是任意自定义类
    Base b = new Base() {
      {
        setName(Inner anonymous class, instance initializer.);
      }
    }

    // result: super class: java.util.HashMap
    System.out.println("super class: " + hm.getClass().getSuperclass().getName());
    // result: class name: com.example.javademo.DoubleBraceTest$2
    System.out.println("class name: " + hm.getClass().getName());
  }
}
\end{javacode}

注意：double braces initialization是不鼓励使用的，因为它本质上是定义了一个
匿名内部类，因此实例化的instance会一直保存对外部类(DoubleBraceTest类)实例
的引用，并且这也会让类加载器管理更多的类。

\section[Polymorphism - 多态]{Polymorphism - 多态}
在Java中(其他OOP中也是如此)，Polymorphism(多态)是一个概念，它用于method的定义，
有两种表现形式：override和overload。两种多态形式各有不同的限定条件。

\subsection[override]{override}
父类方法和子类方法构成override必须满足如下条件：

\begin{enumerate}
  \item 子类方法和父类方法的name、parameters、return type必须完全一样
  \item 子类方法不能缩小(reduce)父类方法的访问权限
  \item 子类方法不能扩大或者改变父类方法的异常范围，详见第\ref{sec:exceptions-in-override}节
\end{enumerate}

注意：final修饰的方法不能被override。

\subsection[overload]{overload}
位于同一个类中或者分别位于父类和子类中的两个方法，构成overload必须满足如下条件：

\begin{enumerate}
  \item parameters(包括参数类型、个数、顺序)不能完全相同
\end{enumerate}

注意，如果两个方法参数完全相同而只是返回值不同，则它们不构成overload关系。

\section[静态方法能否被override]{静态方法能否被override}
静态方法(类方法)能否被覆盖(override)？

这个问题本身就是错误的！

override被设计用于instance methods，而不是用于static methods。
类加载之后，static method放置在Method Area，因此每个类，不论子类父类，都有自己
单独的static field和static method，相互之间没有任何关系。

\begin{javacode}
class Base {
  public static void staticPrint() {
    System.out.println("Base static method");
  }
  public void instancePrint() {
    System.out.println("Base instance method");
  }
}

class Derived extends Base {
  public static void staticPrint() {
    System.out.println("Derived static method");
  }
  @Override
  public void instancePrint() {
    System.out.println("Derived instance method");
  }
}

Base base = new Derived();
// result: Base static method
base.staticPrint();
// result: Derived nstance method
base.instancePrint();
// result: Derived static method
((Derived) base).staticPrint();
\end{javacode}

需要注意的是：static method是静态绑定的，即在编译期就绑定完毕，
因此base.staticPrint()会被绑定到Base类的static method；
而instance method是动态绑定的，即在运行期才会寻找instance数据
(位于Heap中，base的instance数据根据Derived类实例化)，
查找method的bytecode然后绑定。


\section[Exceptions in Java]{Exceptions in Java}
Java中的异常分为两类：checked exception和runtime exception(uncheck exception)，
如图\ref{fig:exceptions}所示，
RuntimeException及其子类叫做runtime exception，也叫做uncheck exception，
Exception的其他子类叫做checked exception。

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{picturedir/JavaExceptions.jpeg}\\
  \caption{Java的异常体系}\label{fig:exceptions}
\end{figure}

\subsection[名字的由来]{名字的由来}
所谓的checked与uncheck指的是compiler的行为，即compiler在编译时(废话，肯定是编译时)
作检查(check)的exception叫做checked exception，其他exception叫做runtime exception，
也叫做uncheck exception，

\begin{javacode}
class ExceptionTest {
  void testCheckedException() throws IOException { }
  void testRuntimeException() throws IndexOutOfBoundsException { }
  void test() {
    testCheckedException(); // compile error
    testRuntimeException(); // no compile error
  }
}
\end{javacode}

\subsection[设计的初衷]{设计的初衷}
在一个方法的实现者角度来看，checked exception意味着我知道在该方法被调用的过程中
可能会发生某些异常，但是对此我无能为力，我只能throws exception(方法签名中)以提醒你，
作为方法调用者，你要自己catch这些异常。比如某个文件正在读取时被其他进程删除了，
又比如正在进行网络数据传输却突然断网了。这些异常是callee用来提醒caller的，compiler
会检查这些异常，提醒caller进行异常捕获。

其他所有的exception都是runtime exception，如NullPointerException，它意在曝露出
方法实现上的错误，如果有，这样的exception越早曝露越好，此时我们必须修改代码来除错。

从两种异常的设计初衷来看，作为方法的调用者(callee)，应该捕获所有checked exception
(废话，不捕获就无法通过编译啊)并作相应处理，如给用户友好的错误提示；而runtime exception
则不应该捕获。

\section[override方法中的exception]{override方法中的exception}
\label{sec:exceptions-in-override}
在子类方法和父类方法进行override时，对子类方法和父类方法所抛出的异常有如下要求：

\begin{enumerate}
  \item 不论父类方法抛出何种异常，子类方法都可以不抛出任何异常
  \item 父类方法和子类方法所抛出的任何runtime异常都不受限制
  \item 子类方法抛出的checked异常必须equal或者derive父类方法抛出的checked异常
\end{enumerate}

\begin{javacode}
class Base {
  public void foo() throws IOException { }
  public void bar() throws IOException { }
  public void base1() throws IOException { }
  public void base2() throws ArithmeticException { }
  public void base3() throws IOException { }
  public void base4() throws ArithmeticException { }
  public void base5() { }
}

class Derived extends Base {
  @Override
  public void foo() throws FileNotFoundException { } // allowed
  @Override
  public void bar() throws SQLException { } // NOT allowed

  @Override
  public void base1() { } // allowed, do not throw any exception
  @Override
  public void base2() throws IndexOutOfBoundsException { } // allowed
  @Override
  public void base3() throws IndexOutOfBoundsException { } // allowed
  @Override
  public void base4() throws IOException { } // NOT allowed
  @Override
  public void base5() throws IOException { } // NOT allowed
}
\end{javacode}

IOException、FileNotFoundException、SQLException都是checked异常，并且
FileNotFound\-Exception是IOException的子类，ArithmeticException和
IndexOutOfBoundsException都是runtime异常。注意，base4(), base5()两种
情况是不允许的！

\emph{为何要作此限制呢？}

考虑如下情形，

\begin{javacode}
Base base = new Derived();
try {
  base.bar();
} catch(??? e) {
  // 这里应该捕获何种异常类型呢？
}
try {
  base.foo();
} catch(IOException e) {
  // 这里应该捕获的异常类型就很明确了！
}
\end{javacode}


\part[Java IO]{Java IO}
Java的IO库位于java.io.*包中。

\section[面向字节的IO接口]{面向字节的IO接口}
InputStream和OutputStream是面向字节的IO接口，它们处理的是字节流

\subsection[InputStream]{InputStream}
\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{picturedir/inputstream.png}
  \caption{面向字节的InputStream接口}
  \label{fig:inputstream}
\end{figure}

图\ref{fig:inputstream}展示了InputStream的基本接口。
InputStream是一个抽象类，真正使用时都是使用其子类进行实例化。

\subsubsection[FileInputStream]{FileInputStream}
\subsubsection[ByteArrayInputStream]{ByteArrayInputStream}
\subsubsection[ObjectInputStream]{ObjectInputStream}
\subsubsection[PipedInputStream]{PipedInputStream}
\subsubsection[FilterInputStream]{FilterInputStream}

\subsection[OutputStream]{OuttputStream}
\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{picturedir/outputstream.png}
  \caption{面向字节的OutputStream接口}
  \label{fig:outputstream}
\end{figure}

图\ref{fig:outputstream}展示了OutputStream的基本接口。
OutputStream是一个抽象类，真正使用时都是使用其子类进行实例化。
\subsubsection[FileOutputStream]{FileOutputStream}
\subsubsection[ByteArrayOutputStream]{ByteArrayOutputStream}
\subsubsection[ObjectOutputStream]{ObjectOutputStream}
\subsubsection[PipedOutputStream]{PipedOutputStream}
\subsubsection[FilterOutputStream]{FilterOutputStream}


\section[面向字符的IO接口]{面向字符的IO接口}
\subsection[面向字符的Input接口]{面向字符的Input接口}
\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{picturedir/reader.png}
  \caption{面向字符的Reader接口}
  \label{fig:reader}
\end{figure}

图\ref{fig:reader}展示了Reader的基本接口。

\subsection[面向字符的Output接口]{面向字符的Output接口}
\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{picturedir/writer.png}
  \caption{面向字符的Writer接口}
  \label{fig:writer}
\end{figure}

图\ref{fig:writer}展示了Writer的基本接口。



\part[Java NIO]{Java NIO}



\part[Multi-thread and Concurrency]{Multi-thread Concurrency}
\section[How to create Java thread]{How to create Java thread}

\section[package: concurrency]{package concurrency}

\section[keyword: join]{keyword: join}
join用于等待其他线程结束，如otherThread.join()，当前线程将会等待
otherThread结束后才会退出。

实例：

\begin{javacode}
public class JoinTest {
  public static void main(String[] args) {
    Thread t1 = new Thread(new MyRunnable(), "Thread-1");
    Thread t2 = new Thread(new MyRunnable(), "Thread-2");

    t1.start();
    t2.start();
    System.out.println("Main thread end.");
  }
}

class MyRunnable implements Runnable {
  String name = Thread.currentThread().getName();
  @Override
  public void run() {
    System.out.println("wtf: " + name);
    try {
      Thread.sleep(3000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    System.out.println(">>> " + Thread.currentThread().getName());
  }
}
\end{javacode}

注意：wtf那一行输出的是“main”，即name变量保有的是主线程的名字，WTF!

可能的输出，

\begin{bashcode}
Main thread end.
wtf: main
wtf: main
>>> Thread-1
>>> Thread-2
\end{bashcode}

\section[keyword: synchronized]{keyword: synchronized}
'synchronized'关键字用于锁住资源，从而保证多线程环境下，同一时刻只有一个
线程能拥有锁住的资源，资源用完之后释放锁。

有两种synchronized方式：
\begin{enumerate}
\item synchronized block: 只锁住该block里的资源
\item synchronized method: 锁住整个对象；如果是static方法，就锁住该Class
\end{enumerate}
另外还需注意：
\begin{itemize}
\item synchronized关键字“不能”用于构造函数和变量
\item synchronized影响效率，在真正必须的时候才使用
\item synchronized只在同一个JVM实例上有效
\item synchronized不要用于non-private的对象，以及有getter函数的private对象
\item synchronized不要用于常量池中的对象，如String对象
\end{itemize}
推荐使用方法：\\
\begin{javacode}
// dummy object variable for synchronization
private Object mutex = new Object();
int count = 0;
synchronized(mutex) {
    count++;
}
\end{javacode}

注意：synchronized需要程序员自觉才行，如果在某个线程程序员没有
使用synchronized而是直接就count++，此时synchronized就被人为的绕过
去了，尤其是用继承Thread类的方法创建线程时，这种情况更容易发生。

不要这样用：\\
\begin{javacode}
public class MyObject {
    // will lock on the object's monitor
    public synchronized void doSomething() { /* do something...*/ }

    MyObject myObject = new Myobject();
    synchronized(myObject) {
        while(true) {
            Thread.sleep(Integer.MAX_VALUE);
        }
    }
}
\end{javacode}

两个synchronized锁住的是同一个monitor，所以一旦第二个执行，
doSomething()将不可能再执行，导致死锁和DoS(Denial of Service)。

不要这样用：\\
\begin{javacode}
public class MyObject {
    public Object lock = new Object();
    public void doSomething() {
        synchronized(lock) {
            // do something...
        }
    }
}

MyObject myObject = new MyObject();
// 修改lock的引用，doSomething()函数有可能并发执行，
// 同理，有getter函数的private lock也是一样的
myObject.lock = new Object();
\end{javacode}



\section[keyword: wait, notify and notifyAll]{keyword: wait, notify and notifyAll}
wait, notify, notifyAll三个函数用于多线程竞争某个资源的情况，这三个函数在调用
之前都必须先取得“竞态资源”的monitor才行，所以这三个函数必须放到sychronized中
才行。

下面是一个生产者、消费者的实例。

测试用例：

\begin{javacode}
public class WaitNotifyTest {
  public static void main(String[] args) {
    Message msg = new Message("Init Message");
    new Thread(new Waiter(msg), "waiter1").start();
    new Thread(new Waiter(msg), "waiter2").start();

    new Thread(new Notifier(msg), "notifier").start();
    System.out.println("Main thread end.");
  }
}
\end{javacode}

竟态资源：

\begin{javacode}
class Message {
  private String msg;

  public Message(String str) {
    this.msg = str;
  }
  public String getMsg() {
    return msg;
  }
  public void setMsg(String str) {
    this.msg = str;
  }
}
\end{javacode}

消费者：

\begin{javacode}
class Waiter implements Runnable {
  private Message msg;

  public Waiter(Message m) {
    this.msg = m;
  }
  @Override
  public void run() {
    String name = Thread.currentThread().getName();
    synchronized (msg) {
      try {
        System.out.println("*" + name + "*" + " waiting msg at: "
                           + System.currentTimeMillis());
        msg.wait();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      System.out.println("*" + name + "*" + " got msg at: "
                         + System.currentTimeMillis());
      // process the message now
      System.out.println("*" + name + "*" + " process msg: " + msg.getMsg());
    }
  }
}
\end{javacode}

生产者：

\begin{javacode}
class Notifier implements Runnable {
  private Message msg;

  public Notifier(Message msg) {
    this.msg = msg;
  }
  @Override
  public void run() {
    String name = Thread.currentThread().getName();
    System.out.println("*" + name + "*" + " started.");
    try {
      Thread.sleep(1000);
      synchronized (msg) {
        msg.setMsg("\"This is " + "*" + name + "*'s" + " msg.\"");
        //msg.notify();
        msg.notifyAll();
      }
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }
}
\end{javacode}

注意，notifyAll会把所有等待的线程都唤醒，但是无法确定这些线程
的执行顺序，每次只能执行一个，而notify函数只能唤醒一个，随机的
一个。

执行顺序是这样的：

线程A获得msg.lock之后进入synchronized block，调用msg.wait()
阻塞A线程，然后释放msg.lock（并未退出wait()方法，在synchronized中，
没有lock就寸步难行）。线程B获得msg.lock之后进入synchronized block，
调用msg.notify()/msg.notifyAll()，通知线程A或者其他等待msg.lock
的线程，等待线程被唤醒，但是没有msg.lock仍然无法运行，之后线程B
继续执行synchronized block剩余的内容，执行完之后释放msg.lock，
正在等待的线程（如线程A）会取得msg.lock然后完成wait()方法，进而
完成synchronized block的剩余内容，之后释放msg.lock。如果线程B
调用的是msg.notifyAll()并且还有其他等待线程的话，其他等待线程中的
一个会获得msg.lock，然后执行完msg.wait()方法继而完成
synchronized block之后释放msg.lock，依次重复，直到所有等待线程
都完成这个过程，整个同步过程也就结束了。


\part[JVM]{Java Virtual Machine}
Java Virtural Machine(JVM)可能有三种解释：
\begin{enumerate}
  \item The abstract specification，即JVM规范
  \item A concrete implementation，即一个具体的JVM实现
  \item A runtime instance，即一个运行时JVM实例
\end{enumerate}
简单一点儿理解，Java Virtual Machine可能指的是"specification"、"implementation"、
"instance"。

\section[Lifetime of JVM instance]{Lifetime of JVM instance}
JVM instance的使命就是“运行Java application”，Java application启动时创建，结束时
销毁。Java application和JVM instance是一一对应的，即每个Java application都运行在
一个“单独”的JVM instance中，如果一个电脑上同时运行了3个Java application，那么将会有
3个JVM instance同时存在。

\section[Layout of .class file]{Layout of .class file}
这一节的内容来自\href{http://hxraid.iteye.com/blog/687660}{这个}网页。

\subsection[整体布局]{整体布局}
.class文件整体布局如图\ref{fig:dotclass}所示。

\begin{figure}
  \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=.4\textwidth]{picturedir/JavaClassFileLayout.png}\\
  \caption{.class文件布局}\label{fig:dotclass}
\end{figure}

class文件由8比特的字节流组成，全部字节流构成15个有意义的条目。

\begin{enumerate}
  \item magic number，占4个字节(0xCAFEBABE)，表明一个文件是.class文件
  \item minor version, major version，各占2个字节，主次版本号
  \item constant pool count，占2个字节，常量池大小
  \item constant pool，大小不固定，常量池，详见\ref{sec:constantpool}节
  \item access flag，占2个字节，表明类/接口、访问修饰符、是否抽象类、是否final类
  \item this class，占2个字节，它是一个常量池索引
  \item super class，占2个字节，它是一个常量池索引
  \item interface count, interface，接口数量以及接口的具体信息
  \item fields count, fields，属性的数量及其具体信息
  \item method count, methods，方法的数量及其具体信息(包括方法的实现)
\end{enumerate}

\subsection[常量池]{常量池}
\label{sec:constantpool}
常量池是有一个个item组成，就像一个表格。item有如表\ref{tab:constantpooltype}
所示的这些类型，不同类型有各自存在的format。

\input{srcdir/constant-pool-format.tex}

需要注意的是真正的实体数据是<data>，包括primitive type的<data>以及Unicode字符的<data>，
其他的索引最终都要落到某个Unicode的<data>处。

\subsection[实例解析]{实例解析}
以如下代码编译出来的class文件，逐个字节分析。

\begin{javacode}
package hr.test;
public class ClassTest {
  private int itemI = 0;
  private static String itemS = "我们";
  private final float PI = 3.1415926F;

  public ClassTest() { }

  public int getItemI() {
    return this.itemI;
  }

  public static String getItemS() {
    return itemS;
  }

  public static void main(String[] args) {
    ClassTest ct = new ClassTest();
  }
}
\end{javacode}

下面是逐字节分析，每个字节翻译为十进制数字。

\input{srcdir/analyse.txt}


\section[static-binding vs dynamic binding]{static-binding vs dynamic binding}


\end{document}
