\documentclass[a4paper,11pt]{article}

\input{../styles/article_preamble}
\input{../styles/tikz_preamble}

\sybtitle{Linux Notes}
\sybauthor{孙延宾}
\sybdate{\today}

\begin{document}
  \tt % I love Typewriter font.
%%%%%%%% the title page and toc %%%%%%%%%%
  \pagestyle{header}
  \sybmaketitle
  \tableofcontents
  \newpage

%%%%%%% the main content %%%%%%%%%
  \pagestyle{main}
  \setcounter{page}{1}

  \part[Useful Commands]{Useful Commands}
  \section[find命令使用举例]{find命令使用举例}
  find是Linux上的重量级的命令，使用方法多样且比较复杂，以下分节举例说明其使用方法。
  内容主要来源于thegeekstuff.com，find命令只是通过各种条件查找文件，而不会深入到文件
  中去搜索，要进行文件内容的搜索请使用grep命令。\par
  \bigskip
  FAQ：文件名何时该用双引号括起来，何时又可以省略呢？\\
  答：使用双引号是为了防止文件名中包含空格，尤其是包含通配符时，如"*.zip"，其他情况下
  可以省略双引号。

  \subsection[通过文件名查找文件]{通过文件名查找文件}
  默认搜索路径为当前路径：
  \cmd{find -name "myfile.c"}

  忽略文件名的大小写：
  \cmd{find -iname "myfile.c"}

  \subsection[按照文件类型查找]{按照文件类型查找}
  查找当前目录下的socket文件：
  \cmd{find . -type s}
  查找当前目录下的所有目录：
  \cmd{find . -type d}
  查找当前目录下的一般文件：
  \cmd{find . -type f}
  查找当前目录下的隐藏文件(Linux上以“.”开头的文件为隐藏文件)：
  \cmd{find . -type f -name ".*"}
  查找当前目录下的隐藏目录：
  \cmd{find . -type d -name ".*"}

  \subsection[相反匹配]{相反匹配}
  -not可以将“紧随”其后的(一个)条件置反。
  \cmd{find -not -iname "myfile.c"}

  \subsection[查找空文件]{查找空文件}
  查找当前目录下的所有空文件：
  \cmd{find . -empty}

  \subsection[按照文件大小查找]{按照文件大小查找}
  文件大小的排序需要借助其他命令，不过Linux shell就是干这个的，
  管道可不是徒有虚名哦！

  查找最大的5个文件：
  \cmd{find . -type f -exec ls -s \{\} \bs; | sort -n -r | head -5}
  ls的-s表示打印“文件”的大小；sort的-n表示按照number计算大小，-r表示reverse。

  查找最小的5个非空文件：
  \cmd{find . -not -empty -type f -exec ls -s \{\} \bs; | sort -n | head -5}

  其实find本身提供-size选项：
  查找大于100M的文件：
  \cmd{find . -size +100M}
  查找小于100M的文件：
  \cmd{find . -size -100M}
  查找等于100M的文件：
  \cmd{find . -size 100M}

  \subsection[通过与其他文件比较修改时间查找文件]{通过与其他文件比较修改时间查找文件}
  这个功能确实比较少见。

  查找比myfile.c更新的文件：
  \cmd{find -newer "myfile.c"}


  \subsection[限定搜索目录的深度]{限定搜索目录的深度}
  -mindepth、-maxdepth可以限定find命令的搜索最小、最大深度，
  1表示当前搜索目录，数字表示“层级数”而非“第几级”：
  \cmd{find -mindepth 3 -maxdepth 5 -name "myfile.c"}

  \subsection[在查找到的文件上执行命令]{在查找到的文件上执行命令}
  可以这样理解："\{\}"代表查找到的文件名，"\{\}"与"\bs;"之间的内容为要执行命令的参数。
  \cmd{find -iname "myfile.c" -exec mv \{\} myfile.c.new \bs;}
  充分利用"\{\}"：
  \cmd{find -iname "myfile.c" -exec mv \{\} \{\}.new \bs;}

  \subsection[find与alias联合]{find与alias联合}
  删除大于100M的zip文件可以这样做：
  \cmd{find . -type f -name *.zip -size +100M -exec rm -i \{\} \bs;}
  然后将这个命令取个名字，方便以后使用：
  \cmd{alias rm100m="find . -type f -name \bs"*.zip\bs" -size +100M -exec rm -i \{\} \bs;"}
  类似的：
  \cmd{alias rm1g="find . -type f -name \bs"*.zip\bs" -size +1G -exec rm -i \{\} \bs;"}

  \subsection[执行多条命令]{执行多条命令}
  类似于filter(过滤器)，满足条件N就执行命令N。
  \cmd{find . \bs( -name "*.java" -exec "java file: \{\} \bs; \bs), \bs\\
        \hspace*{15ex}\bs( -name "*.xml" -exec "xml file: \{\} \bs; \bs)}
  注意：\par
  \bs(、\bs)、\bs;以及中间的逗号，他们两边的空格不能丢，"*.java"、"*.xml"两边的引号也不能丢，这点儿比较蛋疼啊！


  \section[grep命令使用举例]{grep命令使用举例}
  grep: Global search Regular Expression and Print out the line.\\
  grep命令用于从文件中搜索字符串，基本命令格式：
  \cmd{grep [options] <PATTERN> <file-list>}
  其中<PATTERN>为正则表达式，<file-list>可以使用通配符，如"*.c"。

  \subsection[在文件中搜索指定字符串]{在文件中搜索指定字符串}
  在file.c、file.h两个文件中搜索字符串"return"：
  \cmd{grep return file.c file.h}
  或者：
  \cmd{grep "return" file.c file.h}
  什么时候pattern需要使用引号呢？当pattern中包含空格的时候！

  \subsection[使用正则表达式]{使用正则表达式}
  pattern使用正则表达式：
  \cmd{grep "return .*;" file.c file.h}

  \subsection[使用通配符]{使用通配符}
  file list可以使用通配符，如在当前目录(不包括子目录)中搜索字符串：
  \cmd{grep "return" *}

  \subsection[使用options]{使用options}
  grep的options可以做很多事情：
  \begin{coloredenumerate}
    \item -r, --recursive: 递归搜索
    \item -w, --word-regexp: 强制pattern匹配单个word
    \item -i, --ignore-case: 忽略pattern的大小写
    \item -v, --invert-match: 选中未选中的行
    \item -n, --line-number: 在输出中显示行所在的行号
    \item -l, --files-with-matches: 只列出包含pattern的文件名
    \item -c, --count: 显示pattern在文件中的匹配数量
  \end{coloredenumerate}

  \subsection[综合起来]{综合起来}
  在当前目录下，递归搜索所有文件，查找字符串：
  \cmd{grep -r "is.*file" *}
  注意正则表达式和通配符的区别！


  \section[chmod命令修改文件权限]{chmod命令修改文件权限}
  文件权限的表示：\par
  \begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    权限 & 字母表示 & 数字表示 \\\hline
    read & r & 4 \\\hline
    write & w & 2 \\\hline
    execute & x & 1 \\\hline
  \end{tabular}
  \end{center}

  文件权限的类别：\par
  \begin{center}
  \begin{tabular}{|c|c|}
    \hline
    权限类别 & 字母表示 \\\hline
    user & u \\\hline
    group & g \\\hline
    other & o \\\hline
  \end{tabular}
  \end{center}

  使用chmod修改文件权限：
  \cmd{chmod \lt 类别\gt \lt +|-\gt\lt 权限\gt\ file1 file2 ...}
  “类别”的可选项有u、g、o和a(all)，权限的可选项有r、w、x，
  “+”表示增加权限，“-”表示减掉权限。

  例如：\par
  为所有类别赋予可执行权限：
  \cmd{chmod a+x filename}
  增加group的写入权限、去掉other的执行权限：
  \cmd{chmod g+w,o-x file1 file2 ...}
  注意：“g+w,o-x”之间不要有空格！

  当然，也可以使用数字计算出各个类别的权限，然后一次性
  处理这些权限，如user可读写、group只读、other只读：
  \cmd{chmod 644 file1 file2 ...}


  \section[rsync命令及其核心算法]{rsync命令及其核心算法}
  问题描述：
  \begin{coloredenumerate}
    \item 在两台电脑之间进行文件同步，如local同步到server
    \item 但是又不想把local的整个文件传送到server
    \item 而是只传递文件的差异部分
  \end{coloredenumerate}
  用普通的diff方法查找文件差异时，需要将两个文件放到同一台电脑上，
  这就要求local将整个文件发送到server上，这与第二条相悖。

  那要如何才能做到不用传递整个文件却能比较文件差异呢？
  rsync的做法是将整个文件分割成小块儿(chunk)，然后将每一小块儿映射成
  checksum字符串，可以认为chunk和checksum之间是一一映射。

  这样，server将所有chunk的checksum发送给local，local按照chunk大小
  读取文件流，取一个chunk就计算checksum，如果在server发送过来的checksum
  中有这个checksum，就表示server上有这一部分，不用发送了；如果没有，
  就略过一个字节，再读取一个chunk，然后重复比对checksum的过程。

  最终local上的文件会被分解为多个部分，其中有些部分在server上已经存在，
  local只做一个标识(和chunk编号)，其他部分在server上没有(这些部分大小不等，
  因为当初分割的时候是一个字节一个字节找出这些部分来的)，需要编号然后
  发送给server。

  server端最终会有一个chunk列表(大小不等)，根据编号重组文件，server
  上本来就有的chunk直接拿来使用，本来没有的，local已经发送过来了，
  于是整个文件就可以重新组合起来。

  该算法之所以能减小数据发送量，关键在于checksum映射，将数据chunk
  映射为checksum字符串，从而减小了数据发送量。


  \section[Linux系统内存布局]{Linux系统内存布局}
  \input{inputdir/linux_memory_layout}


  \section[Java命令行使用方法]{Java命令行使用方法}
  大家几乎都被IDE绑架了，谁还关注命令行java呢？\par
  注意：java的参数都是使用“-”的，不论长格式还是短格式，这跟GNU格式不符。
  \subsection[编译命令：javac]{编译命令：javac}
  \cmd{javac -classpath </path/to/folder;/path/to/.jar;/path/to/.zip>\\
        \hspace*{5em}-sourcepath </path/to/folder;/path/to/.jar;/path/to/.zip>}
  -classpath的值可以是folder、.jar、.zip，其中包含的都是.class文件；\\
  -sourcepath的值可以是folder、.jar、.zip，其中包含的都是.java文件。

  \subsection[运行命令：java]{运行命令：java}
  \cmd{javac -classpath </path/to/folder;/path/to/.jar;/path/to/.zip> runnable}
  -classpath的值可以是folder、.jar、.zip，其中包含的都是.class文件。\\
  runnable是一个.class文件，扩展名.class不要加上。

  \subsection[反汇编命令：javap]{反汇编命令：javap}
  javap是java的反汇编命令，但是很少有人用它来进行反汇编，
  原因是有很多其他工具反汇编工作做的比javap好的多，但是
  用javap来输出.class文件的字节码信息，对于学习JVM来说是
  很有帮助的。
  \cmd{javap -verbose runnable}
  注意：runnable为.class文件，后缀.class不要加上。

  \section[Windows客串：命令行模式启动Emacs]{Windows客串：命令行模式启动Emacs}
  直接在cmd中使用'emacs'启动时，cmd会一直被占用，使用'\&'也不行，可以使用
  'runemacs'代替'emacs'，此为Emacs的命令行模式，cmd不会被占用。

  \section[常用压缩/解压缩命令]{常用压缩/解压缩命令}
  命令行下有很多压缩、解压缩命令，其中tar可以包含很多，另外还有就是zip、rar格式。
  \subsection[zip文件的压缩和解压缩]{zip文件的压缩和解压缩}
  压缩：zip filename.zip dirname\\
  解压：unzip filename.zip
  \subsection[rar文件的压缩和解压缩]{rar文件的压缩和解压缩}
  压缩：rar a filename.rar dirname\\
  解压：rar x filename.rar
  \subsection[使用tar处理不同的压缩和解压缩文件]{使用tar处理不同的压缩和解压缩文件}
  tar的基本使用格式如下：
  压缩：tar <algorithm>cvf filename.tar.<postfix> dirname\\
  解压：tar <algorithm>xvf filename.tar.<postfix>\\
  其中，v表示verbose，f表示file，而各种压缩算法及其对应的后缀如下所示：\par
  \begin{center}
  \begin{tabular}{ccc}
    \hline
    算法 & 字母表示 & 后缀\\ \hline
    gzip & z & .gz\\
    bzip & j & .bz\\
    bzip2 & j & .bz2\\
    compress & Z & Z\\ \hline
  \end{tabular}
  \end{center}
  如采用gzip算法的压缩和解压：\\
  压缩：tar zcvf filename.tar.gz dirname\\
  解压：tar zxvf filename.tar.gz


  \section[curl命令示例]{curl命令示例}
  使用curl命令获取外部IP地址：
  \cmd{curl ifconfig.me}
  注意：Window版本的curl也可以使用该命令！


  \section[树形结构显示文件夹内容]{树形结构显示文件夹内容}
  Windows版本：
  \cmd{tree /F}

  Linux版本：待添加。。。


  \section[pstree显示进程数结构]{pstree显示进程数结构}
  命令如下：
  \cmd{pstree -a -h}
  -a: 显示命令的启动参数\\
  -h: 高亮当前进程
  

\end{document}
