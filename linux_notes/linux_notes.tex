\documentclass[a4paper,11pt]{article}

\input{../styles/article_preamble}
\input{../styles/tikz_preamble}

\sybtitle{Linux Notes}
\sybauthor{孙延宾}
\sybdate{\today}

\begin{document}
  \tt % I love Typewriter font.
%%%%%%%% the title page and toc %%%%%%%%%%
  \pagestyle{header}
  \sybmaketitle
  \tableofcontents
  \newpage

%%%%%%% the main content %%%%%%%%%
  \pagestyle{main}
  \setcounter{page}{1}

  \part[Useful Commands]{Useful Commands}
  \section[find命令使用举例]{find命令使用举例}
  find是Linux上的重量级的命令，使用方法多样且比较复杂，以下分节举例说明其使用方法。
  内容主要来源于thegeekstuff.com，find命令只是通过各种条件查找文件，而不会深入到文件
  中去搜索，要进行文件内容的搜索请使用grep命令。\par
  \bigskip
  FAQ：文件名何时该用双引号括起来，何时又可以省略呢？\\
  答：使用双引号是为了防止文件名中包含空格，尤其是包含通配符时，如"*.zip"，其他情况下
  可以省略双引号。

  \subsection[通过文件名查找文件]{通过文件名查找文件}
  默认搜索路径为当前路径：
  \cmd{find -name "myfile.c"}

  忽略文件名的大小写：
  \cmd{find -iname "myfile.c"}

  \subsection[按照文件类型查找]{按照文件类型查找}
  查找当前目录下的socket文件：
  \cmd{find . -type s}
  查找当前目录下的所有目录：
  \cmd{find . -type d}
  查找当前目录下的一般文件：
  \cmd{find . -type f}
  查找当前目录下的隐藏文件(Linux上以“.”开头的文件为隐藏文件)：
  \cmd{find . -type f -name ".*"}
  查找当前目录下的隐藏目录：
  \cmd{find . -type d -name ".*"}

  \subsection[相反匹配]{相反匹配}
  -not可以将“紧随”其后的(一个)条件置反。
  \cmd{find -not -iname "myfile.c"}

  \subsection[查找空文件]{查找空文件}
  查找当前目录下的所有空文件：
  \cmd{find . -empty}

  \subsection[按照文件大小查找]{按照文件大小查找}
  文件大小的排序需要借助其他命令，不过Linux shell就是干这个的，
  管道可不是徒有虚名哦！

  查找最大的5个文件：
  \cmd{find . -type f -exec ls -s \{\} \bs; | sort -n -r | head -5}
  ls的-s表示打印“文件”的大小；sort的-n表示按照number计算大小，-r表示reverse。

  查找最小的5个非空文件：
  \cmd{find . -not -empty -type f -exec ls -s \{\} \bs; | sort -n | head -5}

  其实find本身提供-size选项：
  查找大于100M的文件：
  \cmd{find . -size +100M}
  查找小于100M的文件：
  \cmd{find . -size -100M}
  查找等于100M的文件：
  \cmd{find . -size 100M}

  \subsection[通过与其他文件比较修改时间查找文件]{通过与其他文件比较修改时间查找文件}
  这个功能确实比较少见。

  查找比myfile.c更新的文件：
  \cmd{find -newer "myfile.c"}


  \subsection[限定搜索目录的深度]{限定搜索目录的深度}
  -mindepth、-maxdepth可以限定find命令的搜索最小、最大深度，
  1表示当前搜索目录，数字表示“层级数”而非“第几级”：
  \cmd{find -mindepth 3 -maxdepth 5 -name "myfile.c"}

  \subsection[在查找到的文件上执行命令]{在查找到的文件上执行命令}
  可以这样理解："\{\}"代表查找到的文件名，"\{\}"与"\bs;"之间的内容为要执行命令的参数。
  \cmd{find -iname "myfile.c" -exec mv \{\} myfile.c.new \bs;}
  充分利用"\{\}"：
  \cmd{find -iname "myfile.c" -exec mv \{\} \{\}.new \bs;}

  \subsection[find与alias联合]{find与alias联合}
  删除大于100M的zip文件可以这样做：
  \cmd{find . -type f -name *.zip -size +100M -exec rm -i \{\} \bs;}
  然后将这个命令取个名字，方便以后使用：
  \cmd{alias rm100m="find . -type f -name \bs"*.zip\bs" -size +100M -exec rm -i \{\} \bs;"}
  类似的：
  \cmd{alias rm1g="find . -type f -name \bs"*.zip\bs" -size +1G -exec rm -i \{\} \bs;"}

  \subsection[执行多条命令]{执行多条命令}
  类似于filter(过滤器)，满足条件N就执行命令N。
  \cmd{find . \bs( -name "*.java" -exec "java file: \{\} \bs; \bs), \bs\\
        \hspace*{15ex}\bs( -name "*.xml" -exec "xml file: \{\} \bs; \bs)}
  注意：\par
  \bs(、\bs)、\bs;以及中间的逗号，他们两边的空格不能丢，"*.java"、"*.xml"两边的引号也不能丢，这点儿比较蛋疼啊！


  \section[grep命令使用举例]{grep命令使用举例}
  grep命令用于从文件中搜索字符串，基本命令格式：
  \cmd{grep [options] <PATTERN> <file-list>}
  其中<PATTERN>为正则表达式，<file-list>可以使用通配符，如"*.c"。

  \subsection[在文件中搜索指定字符串]{在文件中搜索指定字符串}
  在file.c、file.h两个文件中搜索字符串"return"：
  \cmd{grep return file.c file.h}
  或者：
  \cmd{grep "return" file.c file.h}
  什么时候pattern需要使用引号呢？当pattern中包含空格的时候！

  \subsection[使用正则表达式]{使用正则表达式}
  pattern使用正则表达式：
  \cmd{grep "return .*;" file.c file.h}

  \subsection[使用通配符]{使用通配符}
  file list可以使用通配符，如在当前目录(不包括子目录)中搜索字符串：
  \cmd{grep "return" *}

  \subsection[使用options]{使用options}
  grep的options可以做很多事情：
  \begin{coloredenumerate}
    \item -r, --recursive: 递归搜索
    \item -w, --word-regexp: 强制pattern匹配单个word
    \item -i, --ignore-case: 忽略pattern的大小写
    \item -v, --invert-match: 选中未选中的行
    \item -n, --line-number: 在输出中显示行所在的行号
    \item -l, --files-with-matches: 只列出包含pattern的文件名
    \item -c, --count: 显示pattern在文件中的匹配数量
  \end{coloredenumerate}

  \subsection[综合起来]{综合起来}
  在当前目录下，递归搜索所有文件，查找字符串：
  \cmd{grep -r "is.*file" *}
  注意正则表达式和通配符的区别！


  \section[chmod命令修改文件权限]{chmod命令修改文件权限}
  文件权限的表示：\par
  \begin{center}
  \begin{tabular}{|c|c|c|}
    \hline
    权限 & 字母表示 & 数字表示 \\\hline
    read & r & 4 \\\hline
    write & w & 2 \\\hline
    execute & x & 1 \\\hline
  \end{tabular}
  \end{center}

  文件权限的类别：\par
  \begin{center}
  \begin{tabular}{|c|c|}
    \hline
    权限类别 & 字母表示 \\\hline
    user & u \\\hline
    group & g \\\hline
    other & o \\\hline
  \end{tabular}
  \end{center}

  使用chmod修改文件权限：
  \cmd{chmod \lt 类别\gt \lt +|-\gt\lt 权限\gt\ file1 file2 ...}
  “类别”的可选项有u、g、o和a(all)，权限的可选项有r、w、x，
  “+”表示增加权限，“-”表示减掉权限。

  例如：\par
  为所有类别赋予可执行权限：
  \cmd{chmod a+x filename}
  增加group的写入权限、去掉other的执行权限：
  \cmd{chmod g+w,o-x file1 file2 ...}
  注意：“g+w,o-x”之间不要有空格！

  当然，也可以使用数字计算出各个类别的权限，然后一次性
  处理这些权限，如user可读写、group只读、other只读：
  \cmd{chmod 644 file1 file2 ...}


  \section[rsync命令及其核心算法]{rsync命令及其核心算法}
  问题描述：
  \begin{coloredenumerate}
    \item 在两台电脑之间进行文件同步，如local同步到server
    \item 但是又不想把local的整个文件传送到server
    \item 而是只传递文件的差异部分
  \end{coloredenumerate}
  用普通的diff方法查找文件差异时，需要将两个文件放到同一台电脑上，
  这就要求local将整个文件发送到server上，这与第二条相悖。

  那要如何才能做到不用传递整个文件却能比较文件差异呢？
  rsync的做法是将整个文件分割成小块儿(chunk)，然后将每一小块儿映射成
  checksum字符串，可以认为chunk和checksum之间是一一映射。

  这样，server将所有chunk的checksum发送给local，local按照chunk大小
  读取文件流，取一个chunk就计算checksum，如果在server发送过来的checksum
  中有这个checksum，就表示server上有这一部分，不用发送了；如果没有，
  就略过一个字节，再读取一个chunk，然后重复比对checksum的过程。

  最终local上的文件会被分解为多个部分，其中有些部分在server上已经存在，
  local只做一个标识(和chunk编号)，其他部分在server上没有(这些部分大小不等，
  因为当初分割的时候是一个字节一个字节找出这些部分来的)，需要编号然后
  发送给server。

  server端最终会有一个chunk列表(大小不等)，根据编号重组文件，server
  上本来就有的chunk直接拿来使用，本来没有的，local已经发送过来了，
  于是整个文件就可以重新组合起来。

  该算法之所以能减小数据发送量，关键在于checksum映射，将数据chunk
  映射为checksum字符串，从而减小了数据发送量。
  
  \input{inputdir/linux_memory_layout}


\end{document}
