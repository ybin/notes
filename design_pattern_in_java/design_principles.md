
__接口即功能__。唯有__功能__，无他。

SOLID原则()：

1. "S" - Single Responsibility Principle，单一职责原则  
	一个类只完成一个功能。如果一个类完成多个功能，那么这些功能就会耦合在一起，改变一个功能有可能就破坏其他功能。
2. "O" - Open Closed Principle，开放闭合原则  
	对扩展开放，对修改封闭，即在不改变原有代码的基础上做扩展。
3. "L" - Liskov Substitution Principle，里氏替换原则  
	子类必须可以替代父类，即子类只对父类扩展功能而非缩减。也就是说把子类对象放置到原本该用父类对象的地方是毫无问题的。
4. "I" - Interface Segregation Principle，接口分离原则  
	> Clients should not be forced to depend upon interfaces that they do not use.  
	> 客户类不应该被强迫依赖那些他们并不需要的接口。
	
	也就是说一个接口只应该实现一个功能，鼓励使用”瘦“接口而避免”胖“接口。如果一个接口(函数)实现了多个功能，
	而一个客户只需要其中一个功能，他也必须实现该接口，那么其他客户需要更改其他功能时势必会牵涉到这个客户。
5. "D" - Dependency Injection Principle，依赖注入原则  
	”依赖注入“是控制反转(Inversion of Control Principle)的一种实现方式。所以该原则实际讲的是控制反转。  
	传统方式是客户类实例化依赖类，这里的实例化即是一种耦合。想象一下，所有的类都是独立的，谁跟谁都没有任何关系，
	然后我们有一个超级容器(或者叫平台)，它会自动计算所有类之间的依赖关系，我们从某一个类开始运行，当需要某个功能(而不是具体类)时，
	容器自动为它分配，即注入依赖关系，至于被依赖的类是什么，客户类从来不知道也无需过问。


其他原则：

1. 多用组合，少用继承
2. 只对接口编程，而不是针对实现编程
3. 避免重复，DRY( Don't Repeat Yourself)  
	重复不是指代码的重复而是只功能的重复。比如两个功能的代码实现几乎一致，如果将两个功能合为一个函数将会节省很多代码，
	但是这是不对的，它违反了接口分离原则。