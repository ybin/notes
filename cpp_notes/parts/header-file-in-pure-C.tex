\section[header file in pure C]{C语言中的头文件}
C语言中的头文件到底有什么作用，为何要使用头文件，只提供头文件
能否编译通过？这一节来回答这些问题。其实所有这些问题都可以归结
为一个问题，头文件到底有什么用？！

头文件只在.c文件中存在\#include时才被使用到，编译器以.c文件为单位，
每个.c文件单独编译，如果没有.c文件而只有.h文件，编译无法进行，
链接器以.o(目标文件)为单位，它将一个或者多个目标文件链接为最终
的可执行文件。

我们可以在.c文件中类型声明(如struct, union等)、定义变量(变量的声明和定义是一会儿事儿)、
声明函数、定义函数(函数的声明和定义不同)，其中，
\emph{函数可以随意声明任意次，甚至只声明不定义都可以，但是只能定义一次！}
如果类型声明、宏定义都在.c中进行，其他.c文件要使用时也要再次声明，
因为每个.c文件单独编译嘛，为了方便，我们把这些公共的内容放到一个
单独的文件中，哪个.c文件使用只需include一下即可，这个公共文件就是
头文件。

那到底.h中可以放什么内容呢，答案是什么内容都可以，编译器不认识
.h文件，.h文件是由预处理器(preprocessor)进行处理的，预处理器将
.h文件的内容复制到.c文件中，形成一个中间文件，然后交由编译器进行
编译。这在规则上是没有问题的，但是现实中确实一团糟。

一般来说，.h中只放“声明”(declaration)性的内容，如
\begin{itemize}
  \item 类型声明 - struct myNewDataType {}
  \item 宏定义
  \item 函数声明
\end{itemize}
声明性的内容是给编译器看的，编译器处理完之后便不复存在了（链接器看不到），
而把定义性的内容放到.c文件中，这些内容是给链接器看的，它们需要
实实在在的分配内存。

如果把定义性的内容放到.h文件中会如何呢，比如把全局变量放到.h
文件中定义并初始化，这会造成“重复定义”从而无法链接通过（有些编译器
会区分强弱符号，然后进行合并，所以重复的全局变量定义有时也不会报出
编译错误），又比如把函数的定义放到.h文件中，然后在多个.c文件中
include给.h文件，最后多个.o文件链接时就会出现链接错误。

以下内容需要格外注意，
\begin{enumerate}
  \item 函数声明\\
  函数声明可以任意多次进行，甚至同一个.c文件中都可以声明多次，也可以只声明不定义(实现)，
  着有时会造成困扰，如在创建函数库时，\\
  \begin{cppcode}
  // lib.h
  int add(int a, int b); // 压根儿没我什么事儿
  // lib.c
  void add() {
    printf("function add()\n");
  }
  // test.c
  #include "lib.h"
  int main() {
    add();
    return 0;
  }
  \end{cppcode}
  
  没有任何问题(gcc会报错，tcc则好的不能再好)。
  \item 编译时不需要任何.h或者其他辅助文件，\\
  \begin{cppcode}
  int main() {
    call_special_func(); // 谁也不知道这是什么函数，但是没关系，编译OK！
    return 0;
  }
  \end{cppcode}

  但是链接时必须提供对应的函数定义（一般是在.so文件中），.h文件其实可有可无！
  \item .h文件并非必不可少的，使用其他函数库时，没有.h文件一样可以编译、链接、运行，
  .h只是启到曝露接口的作用，毕竟只有一个.so文件时，谁也不知道它里面都有什么函数可以用。
\end{enumerate}
